% !TeX encoding = windows-1250
\chapter{Opis problema}

\qquad Cilj ovog rada je napraviti funkcionalnu aplikaciju za upravljanje robotom i kartiranje okoline koristeæi Unity razvojno okruženje. Jedna od bitnih stavki u navedenom zadatku jest komunikacija i razmjena podataka izmeðu ROSa i Unityja. Potrebno je pronaæi i testirati alat koji æe imati najbolje znaèajke za svrhu ovog rada iz razloga što ne postoji službena programska podrška koja podržava i omoguæuje korištenje ROSa zajedno s Unity razvojnim okruženjem. Na navedeni problem komunikacije i razmjene podataka nadovezuje se i izazov kako dobivene podatke toèno iskoristiti i prikazati u Unityju. Takoðer, uz prikaz podataka u Unityju, potrebno je moæi i slati naredbe u ROS da bi se ispunio zahtjev upravljanja robotom.

\section{ROS\#}

\qquad ROS\# knjižnica sadrži set alata za adaptaciju i interakciju ROSa s Unityjem. Ista veæinski rješava problem komunikacije izmeðu ROSa i Unitya, ali ne u cijelosti. Za kompleksnije stvari kao što je kartiranje, potrebno je proširiti moguænosti ROS\#a na naèin da se omoguæi intuitivno i efikasno èitanje ROS poruka. Takoðer treba riješiti problem kako iskoristiti i prikazati dobivene podatke u Unity ekosustavu. Velika prednost ROS\#a je što omoguæava ROS i Unity komunikaciju bez posebnih implementacijskih detalja, što znaèi da ga je dovoljno uvesti u Unity te upisati IP adresu gdje se ROS nalazi da bi se otvorila veza izmeðu ROSa i Unityja.

Navedeni alat ima i moguænost uvoza URDF (eng. Unified Robot Description Format) modela robota u Unity i ujedno je to jedini naèin za efikasno dobivanje modela robota u Unityju. URDF datoteka je pisana u XML formatu i opisuje model robota. \cite{urdf}

\subsection{Alternativni alati}

\qquad Uz ROS\# postoje još dva potencijalna alata koji služe za istu svrhu:
\begin{enumerate}
	\item \textbf{Unity Robotics Hub} - Službeni Unity alat koji se razvija od strane tvrtke \emph{Unity Technologies}. Navedeni alat je manje popularan od ROS\# alata, no ubrzano raste. Dijelovi Unity Robotics Huba su proizašli iz ROS\#a, a to su alat za uvoz URDF modela i TCP konektor koji su dodatno modificirani od strane Unityja. Iako navedeni alat još nije dostigao ROS\# po moguænostima i popularnosti, aktivno se razvija i izraðuju nove inaèice pa bi u skoroj buduænosti mogao postati vodeæi alat za spajanje ROSa i Unityja. \cite{unityroboticshub}
	\item \textbf{Unity ROS} - Alat razvijen od strane privatne osobe koji je zadnje ažuriran prije tri godine te nije doživio veliku popularnost i korištenje od strane ROS i Unity zajednice. Razlog tomu jest loša podrška i limitirane funkcionalnosti alata. \cite{unityros}
\end{enumerate}

Iako svi navedeni alati imaju slièni temelj za uspostavljanje komunikacije izmeðu ROSa i Unityja, ROS\# i dalje vodi na ljestvici popularnosti svojom fleksibilnošæu, veæim moguænostima te podrškom zajednice i programera.

\clearpage

\section{Unity i aplikacija}
\qquad S obzirom da je Unity poznat kao dobar alat za razvijanje softvera za više platforma odjednom, isti æe se iskoristiti na naèin da se ciljna aplikacija napravi kako bi ista bila kompatibilna za:
\begin{enumerate}
	\item Linux Ubuntu - Na prvom mjestu se nalazi Ubuntu iz razloga što se cijeli rad odraðuje na ovom operacijskom sustavu, prvobitno zbog ROSa.
	\item Android - Jedan od veæih zahtjeva danas je imati mobilnu aplikaciju. Posebno je to sluèaj za upravljanje nekim robotom iz razloga što je nošenje prijenosnog raèunala teže. Mobilna aplikacija za upravljanje robotom olakšava i poboljšava korisnièko iskustvo pri upravljanju robota.
	\item Windows - Kao najkorišteniji operacijski sustav danas, prikladno je imati aplikaciju i za njega.
\end{enumerate}
Mac OS aplikaciju je takoðer moguæe napraviti, no zbog tehnièke ogranièenosti preskoèit æe se.

Pri izradi aplikacije za pojedinu platformu, potrebne su neke dorade da bi aplikacija radila na toj platformi. Zahvaljujuæi Unityju i Mono frameworku \cite{monoabout} koji Unity koristi (.NET Standard 2.0 \cite{dotnetstandard}) navedene dorade su dovoljno sitne da je prelazak na drugu platformu relativno bezbolan.

Unatoè tome, neke znaèajke znaju biti nekompatibilne. Kao opæi primjer mogu se navesti naèini interakcije korisnika s aplikacijom, npr. mobilni æe ureðaj imati na raspolaganju razne senzore, zaslon na dodir i sl., ali neæe imati tipkovnicu i miš (osim kod eksplicitnog spajanja dodatnog hardvera), dok se osobno raèunalo uvijek koristi tipkovnicom i mišem, ali veæinom nema iste senzore kao mobilni ureðaj, a i zaslon na dodir nije uvijek prisutan. Iz tog se razloga ne može uvijek implementirati isti naèin interakcije korisnika s aplikacijom za razne platforme i ureðaje, a da bude uvijek funkcionalan.

Još jedan moguæi problem kod implementacije svih potrebnih znaèajki jest moguænost prevelikog protoka podataka, gdje bi moglo doæi do efekta uskog grla (eng. bottleneck). Potrebno je dobro se informirati o tome koliko æe potrebna komunikacija izmeðu ROSa i Unityja za pojedinu znaèajku slati podataka (koliko svaka ROS tema šalje podataka i po kojoj frekvenciji). Ovisno o tome, postoji moguænost da treba:  promijeniti kvalitetu emitirane slike s kamere, smanjiti frekvenciju slanja podataka o kartiranju ili èak i promijeniti naèin stvaranja podataka (npr. druga metoda mapiranja). Postoje sluèajevi koji se neæe moæi procijeniti dok se ne pokuša iste implementirati.

\subsection{Pogled s kamere}

\qquad Implementacija prikaza pogleda s kamere robota u realnom vremenu treba biti napravljena na naèin da se slika nesmetano prikazuje na ekranu, bez obzira na razluèivost. U ovom æe dijelu zadatka trebati paziti na omjer slike u aplikaciji kako bi se izbjeglo potencijalno izoblièenje slike tj. prikaz slike treba biti skalabilan. Sukladno tomu, potrebno je istražiti i isprobati na koji naèin navedenu sliku s kamere prikazati u Unityju.

\subsection{Upravljanje robotom}

\qquad Upravljanje robotom podrazumijeva upravljanje njegovim motorièkim sposobnostima. U ovom æe se radu to ogranièiti na kretanje robota kroz prostor. Potrebno je implementirati da upravljanje robotom bude moguæe na svim navedenim platformama. U ovom koraku najveæi problem predstavljaju prijašnje navedene moguæe razlike u hardveru ureðaja (raèunalo i mobilni ureðaj). Iz tog razloga postoji moguænost da æe se trebati implementirati više metoda upravljanja robotom.

Navedena znaèajka se treba implementirati na naèin da se šalju naredbe na odreðenu ROS temu \cite{rostopic} koja upravlja motorièkim sposobnostima robota. Osnovna ROS tema za tu svrhu jest \textbf{/cmd\_vel} s prioritetom 90 na koju se objavljuju upravljaèke poruke. Postoje još dvije ROS teme koje se mogu koristiti:
\begin{enumerate}
	\item \textbf{/joy\_vel} koja ima najveæi prioritet od 100 i prima upravljaèke naredbe s joysticka.
	\item \textbf{/nav\_vel} s najmanjim prioritetom od 80 koju koristi \emph{move\_base} \cite{movebase} paket za slanje upravljaèkih naredbi.
\end{enumerate}

Svi navedeni naèini primaju poruke \cite{rosmessage} formata \emph{geometry\_msgs/Twist} kao upravljaèke naredbe. \emph{geometry\_msgs/Twist} se sastoji od dva Vector3 tipa podataka, jedan za linearnu brzinu robota (npr. upravljanje naprijed i unatrag), a drugi za kutnu brzinu (okretanje robota). Zbog najjednostavnije primjene koristit æe se popularniju \emph{/cmd\_vel} ROS temu. \cite{roscontrol}

\subsection{Kartiranje}

\qquad Najveæi implementacijski problem predstavlja kartiranje. Pošto je korišteni robot namijenjen u edukacijske svrhe, isti nema kompleksne komponente za interakciju s prostorom, ali opremljen je laserskim skenerom i kamerom. Sukladno tome, potrebno je istražiti dostupne metode i omoguæiti 2D i 3D kartiranje. Postoje popularni alati u ROS sustavu koji to omoguæuju uz pretpostavku da je robot opremljen potrebnim komponentama, npr. laserski skener za 2D kartiranje ili kamera s moguænošæu 3D percepcije (percepcija dubine prostora) za 3D kartiranje prostora. 

Kartiranje okoline može se opisati kao modeliranje okoline robota u specifiènim dimenzijama prostora. Karta okoline može biti u dvije ili tri dimenzije (2D ili 3D), gdje 2D karta izgleda kao tlocrt zgrade, a 3D karta dodatno opisuje dubinu prostora oko robota te se više poistovjeæuje s pravim svijetom. 

Izgradnja 2D karte prostora odraðuje se SLAM (eng. Simultaneous Localization And Mapping) metodom - simultana lokalizacija i kartiranje \cite{slam}. Robot se kreæe u prostoru prikupljajuæi podatke iz svojih senzora pomoæu kojih istovremeno izraðuje 2D kartu prostora i odreðuje vlastiti položaj na toj karti prostora. Odreðivanje položaja robota naziva se lokalizacija. Postoji mnogo SLAM algoritama, stoga je potrebno istražiti koji su prikladni za hardverske moguænosti Turtlebota.

U drugu ruku, 3D kartiranje se neæe koristiti za lokalizaciju veæ samo za izgradnju 3D karte. Lokalizacija u 3D prostoru je takoðer moguæa, ali æe se u ovom radu više raditi na samoj izgradnji karata. Takoðer, Turtlebot se u simulaciji nalazi u zgradi te je stoga 2D lokalizacija dovoljna zbog pravilnog terena. Smisao 3D karte jest bolja interpretacija detalja okoline pošto su u njoj bolje prikazane velièine i oblici objekata u prostoru. Ovdje takoðer postoji više algoritama za implementaciju 3D kartiranja te je takoðer potrebno pronaæi metodu prikadnu za Turtlebota. Osim toga, potrebno je paziti na koji naèin odabrana metoda objavljuje rezultirajuæu 3D kartu da bi se je moglo uspješno koristiti u Unityju.

Kada se kartiranje uspješno pokrene u ROS sustavu, potrebno je rezultirajuæe podatke (kartu) moæi prenijeti u Unity. Ovdje æe trebati analizirati rezultirajuæe podatke da bi se došlo do zakljuèka gdje i kako se trebaju procesirati. Podaci æe se svakako morati procesirati u Unityju prije korištenja, no moguæe je da æe se trebati prije i formatirati na odreðeni naèin da bi dohvat podataka u Unityju bio efikasniji. Za formatiranje podataka najprikladnije je napraviti ROS èvor kojeg se može isprogramirati da èita i formatira podatke ROS tema koje objaljvuje alat za mapiranje kojeg se bude odabralo kao najprikladnijim. Formatirane podatke se tada može ponovno objaviti na isti naèin.

Korištenje dobivenih podataka u Unityju podrazumijeva kako æe se te podatke pretvoriti u vizualni element u aplikaciji. U sluèaju 3D kartiranja cijeli æe se proces trebati optimizirati iz razloga što su 3D elementi raèunski skuplji - svaki 3D element u aplikaciji je zasebni objekt kojeg treba stvoriti i držati u memoriji. Dok 2D elementi se mogu postavljati kao npr. slike ili teksture što drastièno smanjuje potrebu za resursima raèunala jer predstavljaju jedan objekt ili komponentu objekta u aplikaciji.
\clearpage