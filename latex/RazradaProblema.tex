% !TeX encoding = windows-1250
\chapter{Opis problema}

\qquad Cilj ovog rada je napraviti funkcionalnu aplikaciju za upravljanje robotom i mapiranje okoline koristeæi Unity razvojni program. Jedna od bitnih stavki u navedenom zadatku jest komunikacija i razmjena podataka izmeðu ROSa i Unityja. U tu svrhu koristit æe se ROS\# knjižnica koja sadrži set alata za adaptaciju i interakciju ROSa s Unityjem.

\section{ROS\#}

\qquad ROS\# je odabran iz razloga što on veæinski rješava problem komunikacije izmeðu ROSa i Unitya, no ne sasvim. Za kompleksnije stvari kao što je mapiranje, potrebno je proširiti moguænosti ROS\#a na naèin da se omoguæi intuitivno i efikasno èitanje ROS poruka. Takoðer treba rješiti problem kako iskoristiti i prikazati dobivene podatke u Unity ekosustavu. 

Nakon instalacije potrebnih alata, potrebno je iste konfigurirati na naèin da se mogu koristiti sa ROS\#om i Unityjem. U to je ukljuèena i potreba da se ROS\# knjižnica uvede u Unity. Završetkom ovih osnovnih koraka omoguæeno je kretanje s implementacijom glavnog cilja - razvoj aplikacije za upravljanje robotom i mapiranje okoline. 

\subsection{Alternativni alati}

\qquad Uz ROS\# postoje još dva potencijalna alata koji služe za istu svrhu:
\begin{enumerate}
	\item \textbf{Unity Robotics Hub} - Službeni Unity alat koji se razvija od strane tvrtke \emph{Unity Technologies}. Navedeni alat je manje popularan od ROS\# alata no ubrzano raste. Dijelovi Unity Robotics Huba su proizašli iz ROS\#a, a to su alat za uvoz URDF modela i TCP konektor koji su dodatno modificirani od strane Unityja. Iako navedeni alat još nije dostigao ROS\# po moguænostima i popularnosti, aktivno se razvija i izraðuju nove inaèice pa bi u skoroj buduænosti mogao postati vodeæi alat za spajanje ROSa i Unityja. \cite{unityroboticshub}
	\item \textbf{Unity ROS} - Alat razvijen od strane privatne osobe koji je zadnje ažuriran prije tri godine te nije doživio veliku popularnost i korištenje od strane ROS i Unity zajednice. Razlog toga jest loša podrška i limitirane funkcionalnosti alata. \cite{unityros}
\end{enumerate}

Iako svi navedeni alati imaju slièni temelj za uspostavljanje komunikacije izmeðu ROSa i Unityja, ROS\# i dalje vodi na ljestvici popularnosti svojom fleksibilnošæu, veæim moguænostima te podrškom zajednice i programera.


\section{Unity i aplikacija}
\qquad Jednom kad Unity sadrži funkcionalnu ROS\# knjižnicu, dobiva se pristup alatu za uvoženje URDF modela robota, što je ujedno i prvi korak u izradu konkretne aplikacije. Potrebno je uvesti model korištenog robota što ukljuèuje i njegove fizièke i motorièke karakteristike kako bi se ga moglo ispravno prikazati u Unityju te upravljati istim. U tu svrhu potrebno je pokrenuti \emph{publish\_description\_turtlebot.launch} datoteku koja je detaljnije opisana u Dodatku A ovog rada. Prije samog pokretanja ove \emph{launch} datoteke potrebno je navesti u kojem æe se ROS paketu i gdje unutar paketa pronaæi i uèitati URDF model željenog robota. Pokretanjem \emph{launch} datoteke uèitava se URDF model robota te se kroz \emph{file\_server} alat objavljuje kao ROS èvor kojega ROS\# URDF alat može proèitati i uvesti u Unity. Ovo je trenutno jedini naèin za efikasno uvoženje modela robota u Unityju.

S obzirom da je Unity poznat kao dobar alat za razvijanje softvera za više platforma odjednom, isti æe se iskoristiti na naèin da se ciljna aplikacija napravi kako bi ista bila kompatibilna za:
\begin{enumerate}
	\item Linux Ubuntu - Na prvom mjestu se nalazi Ubuntu iz razloga što se cijeli rad radi na ovom operacijskom sustavu, prvobitno zbog ROSa.
	\item Android - Jedan od veæih zahtjeva danas je imati mobilnu aplikaciju. Posebno je to sluèaj za upravljanje nekim robotom iz razloga što je nošenje prijenosnog raèunala teže. Mobilna aplikacija za upravljanje robotom olakšava i poboljšava korisnièko iskustvo pri upravljanju robota.
	\item Windows - Kao najkorišteniji operacijski sustav danas, prikladno je imati aplikaciju i za njega.
\end{enumerate}
Mac OS aplikaciju je takoðer moguæe napraviti, no zbog tehnièke ogranièenosti preskoèit æe se.

Pri izradi aplikacije za pojedinu platformu, potrebne su neke dorade da bi aplikacija radila na toj platformi. Zahvaljujuæi Unityju i Mono frameworku koji Unity koristi (.NET Standard 2.0) navedene dorade su dovoljno sitne da je prelazak na drugu platformu relativno bezbolan.

Unatoè tome, neke znaèajke znaju bit nekompatibilne. Kao opæi primjer mogu se navesti naèini interakcije korisnika s aplikacijom, npr. mobilni æe ureðaj imati na raspolaganju razne senzore, zaslon na dodir i sl., ali neæe imati tipkovnicu i miš (osim kod eksplicitnog spajanja dodatnog hardvera), dok se osobno raèunalo uvijek koristi tipkovnicom i mišem ali veæinom nema iste senzore kao mobilni ureðaj, a i zaslon na dodir nije uvijek prisutan. Iz tog se razloga ne može uvijek implementirati isti naèin interakcije korisnika s aplikacijom za razne platforme i ureðaje a da bude uvijek funkcionalan.

Još jedan moguæi problem kod implementacije svih potrebnih znaèajki jest moguænost prevelikog protoka podataka, gdje bi moglo doæi do efekta uskog grla (eng. bottleneck). Potrebno je dobro se informirati o tome koliko æe potrebna komunikacija izmeðu ROSa i Unityja za pojedinu znaèajku slati podataka (koliko svaka ROS tema šalje podataka i po kojoj frekvenciji). Ovisno o tome, postoji moguænost da treba:  promjeniti kvalitetu emitirane slike s kamere, smanjiti frekvenciju slanja podataka o mapiranju ili èak i promjeniti naèin stvaranja podataka (npr. druga metoda mapiranja). Postoje sluèajevi koje se neæe moæi procjeniti dok se ne iste pokuša implementirati.

\subsection{Pogled s kamere}

\qquad Implementacija prikaza pogleda s kamere robota u realnom vremenu treba biti napravljena na naèin da se slika nesmetano prikazuje na ekranu, bez obzira na razluèivost. Postoje više naèina na koje se može taj problem rješiti, od kojih su dva prikladna:

Postaviti 3D objekt ispred robota koji služi kao platno gdje se postavlja slika s kamere. Platno bi trebalo biti fiksne pozicije u odnosu na poziciju i orijentaciju robota.

Drugi naèin je napraviti 2D Canvas na kojega bi se moglo postaviti komponentu slike s kamere robota. Oba su naèina izvediva, no potrebno ih je isprobati i uviditi moguæe poteškoæe koje bi mogle biti smetnja pri skaliranju slike na razlièite rezolucije i ureðaje.

\subsection{Upravljanje robotom}

\qquad Upravljanje robotom podrazumijeva upravljanje njegovim motorièkim sposobnostima. U ovom æe se radu to ogranièiti na kretanje robota kroz prostor. Potrebno je implementirati da se upravljanje robotom može izvršavati na svim navedenim platformama. Ovdje najveæi problem predstavlja prijašnje navedene moguæe razlike u hardveru ureðaja (raèunalo i mobilni ureðaj). Iz tog razloga postoji moguænost da æe se trebati implementirati više metoda upravljanja robotom.

\subsection{Mapiranje}

\qquad Najveæi implementacijski problem predstavlja mapiranje. Pošto je korišteni robot edukacijske svrhe, isti nema kompleksne komponente za interakciju s prostorom ali opremljen je laserskim skenom i kamerom. Sukladno tome, potrebno je istražiti dostupne metode i omoguæiti 2D i 3D mapiranje. Postoje popularni alati u ROS sustavu koji to omoguæuju uz pretpostavku da je robot opremljen potrebnim komponentama, npr. laserski skener za 2D mapiranje ili kamera s moguænosti 3D percepcije (percepcija dubine prostora) za 3D mapiranje prostora. 

Kada se mapiranje uspješno pokrene u ROS sustavu, potrebno je rezultirajuæe podatke (mapu) moæi prenijeti u Unity. Ovdje æe trebati analizirati rezultirajuæe podatke da bi se došlo do zakljuèka gdje i kako se trebaju procesirati. Podaci æe se svakako morati procesirati u Unityju prije korištenja, no moguæe je da æe se trebati prije i formatirati na odreðeni naèin da bi dohvat podataka u Unityju bio efikasniji. Za formatiranje podataka najprikladnije je napraviti ROS èvor kojega se može isprogramirati da èita i formatira podatke ROS tema koje objaljvuje alat za mapiranje kojeg se bude odabralo kao najprikladnijim. Formatirane podatke se tada može ponovno objaviti na isti naèin.

Korištenje dobivenih podataka u Unityju podrazumijeva kako æe se te podatke pretvoriti u vizualni element u aplikaciji. U sluèaju 3D mapiranja cijeli æe se proces trebati optimizirati iz razloga što su 3D elementi raèunski skuplji - svaki 3D element u aplikaciji je zasebni objekt kojeg treba stvoriti i držati u memoriji. Dok 2D elementi se mogu postavljati kao npr. slike ili teksture što drastièno smanjuje potrebu za resursima raèunala jer predstavljaju jedan objekt ili komponentu objekta u aplikaciji.
\clearpage